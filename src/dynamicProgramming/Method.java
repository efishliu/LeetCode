package dynamicProgramming;

/*

    动态规划专题
    1.子序列问题
        最长递增子序列 LC300

    2.背包问题  https://blog.csdn.net/weixin_40910614/article/details/121820963
        2.1 0-1背包问题  物品只有一个
            LC416   分割等和子集, 要求：能否装满背包
            LC1049  最后一块石头的重量II, 要求：背包最多能装多少
            LC494   目标和, 要求：装满背包的所有可能数
            LC474   一和零, 要求：两个维度的0-1背包

        2.2 完全背包问题  物品没有限制
            !!注意区分组合和排列
            LC518   零钱兑换II，易错点：这是组合问题，应避免重复计算，如[1,2],[2,1]为同一种
            LC377   组合总和IV，这是排列问题，[1,2],[2,1]为不同选择。对于排列问题，不管物品的顺序，即不用设置dp[i]
            LC322   零钱兑换    不区分排列或组合，求最小值问题
            LC279   完全平方数   求最小值问题
            LC139   单词拆分    完全背包问题看是否能够组成s

        2.3 多重背包问题  不同的物品数量不同
        2.4 分组背包问题  按组打包，每组最多选一个

    3.股票买卖问题
        3.1 只能买卖一次的股票买卖 LC121
        3.2 不限次数股票买卖    LC122
        3.3 限定次数K = 2的股票买卖 LC123
        3.4 限定次数的K次的股票买卖 LC188
        3.5 不限次数但是含冷冻期的股票买卖 LC309
        3.6 不限次买卖股票付手续费 LC714

    4.打家劫舍问题
        4.1 相邻不能抢   LC198
        4.2 相邻不能抢，且房屋围成一个环形 LC213
        4.3 相邻不能抢，房屋呈二叉树    LC337

    5.贪心问题之跳跃游戏
        5.1 能否跳跃到最后一个位置 LC55
        5.2 跳到最后一个位置的最小次数 LC45
        5.3 从起始点只能向左或向右跳，能否跳到0位置    LC1306
        5.4 从下标 i 跳到下标 i + 1 、i - 1 或者相同元素值的下标 j，能否跳到终点 LC1345
            该题不能采用DP，而应该采用广度优先遍历


    2.背包问题
        0-1背包问题的通用解法：
            1.(推荐) 采用一维数组解法dp[j]代表重量为j时的状态，注意遍历顺序！
            for(int num : nums)
                for(int j = target; j >= num; j--)
            物品在外层，重量在内层，且内层应该倒序，因为是0-1背包，j倒序是为了每个物品只被添加一次
            2.采用二维数组解法(不推荐，应该与完全背包统一解法，容易与完全背包混淆)
            dp[i][j]表示前i个物品是否可以组成质量为j的情形,，不管遍历顺序
            for(int num : nums)
                for(int j = 1; j <= target; j++)
        -----------------------------------------------------
        完全背包的通用解法：
            !!!注意点：组合不强调元素之间的顺序，排列强调元素间的顺序
            如果[1,2][2,1]算一种情况，则为组合，算两种情况，则为排列
            1.强调的是组合数，物品在外层，背包在内层.
            for(int num : nums)
                for(int j = num; j <= target; j++)
            2.强调的是排列数，背包在外层，物品在内层.
            for(int j = 0; j <= target; j++)
                for(int num : nums)
                    if(j >= num)    dp..
        -----------------------------------------------------
        多重背包问题：
            将多重背包问题换为0-1背包问题解决。

================================================================
    3.股票问题的解决：
            1.  状态：存在3种状态：所处天数i，限定购买次数k，持有和不持有股票(0,1)
            2.  dp[i][k][0]代表在第i天最多购买k次不持有股票的最大利润
            3.  状态转移：
                    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            4.  注意初始化值 dp[0][0] = 0; dp[0][1] = -prices[0];
            5.  返回值为第n-1天的最大利润 dp[n - 1][0]

 */

public class Method {

}
